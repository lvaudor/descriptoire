[["strings.html", "Chapitre 2 Manipuler des strings: package stringr 2.1 Strings 2.2 Expressions régulières", " Chapitre 2 Manipuler des strings: package stringr Par exemple, à l’aide du package stringr Billet de blog ici. str_c() pour combiner des strings stringr::str_c(&quot;abra&quot;,&quot;ca&quot;,&quot;dabra&quot;) ## [1] &quot;abracadabra&quot; stringr::str_c(&quot;Les jeux&quot;,&quot;de mots laids&quot;,&quot;sont pour&quot;,&quot;les gens bêtes&quot;, sep=&quot; &quot;) ## [1] &quot;Les jeux de mots laids sont pour les gens bêtes&quot; 2.1 Strings 2.1.1 détection, remplacement str_detect() détecte un pattern stringr::str_detect(c(&quot;Quarante&quot;,&quot;carottes&quot;,&quot;crues&quot;, &quot;croient&quot;,&quot;que&quot;,&quot;croquer&quot;, &quot;crée&quot;,&quot;des&quot;,&quot;crampes.&quot;), pattern=&quot;cr&quot;) ## [1] FALSE FALSE TRUE TRUE FALSE TRUE TRUE FALSE TRUE str_replace() remplace le pattern par un autre motif stringr::str_replace(&quot;All we hear is Radio ga ga Radio goo goo Radio ga ga&quot;, pattern=&quot;goo&quot;, replacement=&quot;ga&quot;) ## [1] &quot;All we hear is Radio ga ga Radio ga goo Radio ga ga&quot; stringr::str_replace_all(&quot;All we hear is Radio ga ga Radio goo goo Radio ga ga&quot;, pattern=&quot;goo&quot;, replacement=&quot;ga&quot;) ## [1] &quot;All we hear is Radio ga ga Radio ga ga Radio ga ga&quot; Là encore, notez la différence entre str_replace() et str_replace_all()!! 2.1.2 division, correspondance str_split() découpe les strings partout où un pattern (ou motif) est présent stringr::str_split(c(&quot;beau_gros_chat&quot;, &quot;joli_chien&quot;, &quot;vilain_petit_canard&quot;), &quot;_&quot;) ## [[1]] ## [1] &quot;beau&quot; &quot;gros&quot; &quot;chat&quot; ## ## [[2]] ## [1] &quot;joli&quot; &quot;chien&quot; ## ## [[3]] ## [1] &quot;vilain&quot; &quot;petit&quot; &quot;canard&quot; Le pattern (ici “_“) peut être présent un nombre variable de fois, donc les éléments en sortie ne sont pas forcément de la même taille. C’est pourquoi cette fonction renvoie une liste. En revanche, si l’on sait que tous les éléments de l’input seront découpés en autant de morceaux, alors on peut demander une sortie sous forme de matrice, plus pratique à manipuler par la suite, à l’aide de l’argument simplify=TRUE. stringr::str_split(c(&quot;beau_gros_chat&quot;, &quot;joli_petit_chien&quot;, &quot;vilain_petit_canard&quot;), &quot;_&quot;, simplify=TRUE) ## [,1] [,2] [,3] ## [1,] &quot;beau&quot; &quot;gros&quot; &quot;chat&quot; ## [2,] &quot;joli&quot; &quot;petit&quot; &quot;chien&quot; ## [3,] &quot;vilain&quot; &quot;petit&quot; &quot;canard&quot; Cette opération est un peu similaire à celle que réalise la fonction str_match(), que l’on abordera un peu plus tard… 2.1.3 extraction str_extract() extrait le pattern (là où il est présent) stringr::str_extract(c(&quot;L&#39;âne&quot;,&quot;Trotro&quot;,&quot;trotte&quot;,&quot;à une allure&quot;, &quot;traitreusement&quot;,&quot;tranquille&quot;), pattern=&quot;tr&quot;) ## [1] NA &quot;tr&quot; &quot;tr&quot; NA &quot;tr&quot; &quot;tr&quot; Notez la différence entre str_extract() et str_extract_all(): stringr::str_extract_all(c(&quot;L&#39;âne&quot;,&quot;Trotro&quot;,&quot;trotte&quot;,&quot;à une allure&quot;, &quot;traitreusement&quot;,&quot;tranquille&quot;), pattern=&quot;tr&quot;) ## [[1]] ## character(0) ## ## [[2]] ## [1] &quot;tr&quot; ## ## [[3]] ## [1] &quot;tr&quot; ## ## [[4]] ## character(0) ## ## [[5]] ## [1] &quot;tr&quot; &quot;tr&quot; ## ## [[6]] ## [1] &quot;tr&quot; Si un pattern est présent plusieurs fois dans un des éléments du vecteur en input, alors il correspondra à plusieurs éléments dans l’output (ainsi l’output correspond non pas à un vecteur de même taille que l’input, mais à une liste). 2.1.4 comptage, subset str_count() compte les occurrences d’un pattern stringr::str_count(c(&quot;L&#39;âne&quot;,&quot;Trotro&quot;,&quot;trotte&quot;,&quot;à une allure&quot;,&quot;traitreusement&quot;,&quot;tranquille&quot;), pattern=&quot;tr&quot;) ## [1] 0 1 1 0 2 1 str_subset() crée un subset du vecteur où le pattern est présent stringr::str_subset(c(&quot;Quarante&quot;,&quot;carottes&quot;,&quot;crues&quot;, &quot;croient&quot;,&quot;que&quot;,&quot;croquer&quot;, &quot;crée&quot;,&quot;des&quot;,&quot;crampes.&quot;), pattern=&quot;cr&quot;) ## [1] &quot;crues&quot; &quot;croient&quot; &quot;croquer&quot; &quot;crée&quot; &quot;crampes.&quot; 2.1.5 longueur, sous-partie str_length() compte le nombre de caractères dans un string stringr::str_length(&quot;anticonstitutionnellement&quot;) ## [1] 25 ** str_sub()** extrait les caractères de la chaîne, de l’emplacement start à l’emplacement end stringr::str_sub(&quot;youpiyaya&quot;,start=1,end=5) ## [1] &quot;youpi&quot; stringr::str_sub(&quot;youpiyaya&quot;,start=-4) ## [1] &quot;yaya&quot; stringr::str_sub(&quot;youpiyaya&quot;,start=4) ## [1] &quot;piyaya&quot; 2.2 Expressions régulières Les expressions régulières servent à effectuer des recherches de patterns dans les strings en définissant les règles qui régissent ces patterns.Un tuto ici . 2.2.1 classes de caractères et groupes On peut rechercher une classe de caractères en utilisant la notation [...]. Par exemple, si je veux rechercher toutes les voyelles dans mon string: stringr::str_view_all(&quot;youp la boum&quot;, &quot;[aeiou]&quot;) ## [1] │ y&lt;o&gt;&lt;u&gt;p l&lt;a&gt; b&lt;o&gt;&lt;u&gt;m Remarquez bien la différence: stringr::str_view_all(&quot;A132-f445-e34-C308-M2244-Z449-E18&quot;, &quot;[308]&quot;) ## [1] │ A1&lt;3&gt;2-f445-e&lt;3&gt;4-C&lt;3&gt;&lt;0&gt;&lt;8&gt;-M2244-Z449-E1&lt;8&gt; stringr::str_view_all(&quot;A132-f445-e34-C308-M2244-Z449-E18&quot;, &quot;308&quot;) ## [1] │ A132-f445-e34-C&lt;308&gt;-M2244-Z449-E18 Si l’on veut désigner un caractère quelconque, alors on peut utiliser la notation .. Par exemple, si l’on souhaite rechercher n’importe quel caractère (excepté le retour à la ligne) suivi d’une lettre minuscule: stringr::str_view_all(&quot;32a-B44-552-98eEf&quot;, &quot;.[a-z]&quot;) ## [1] │ 3&lt;2a&gt;-B44-552-9&lt;8e&gt;&lt;Ef&gt; 2.2.2 caractères spéciaux Si je veux trouver tous les points, points d’interrogation ou points d’exclamation: stringr::str_view_all(c(&quot;Allô, John-John? Ici Joe la frite. Surprise!&quot;), &quot;[\\\\.\\\\?\\\\!]&quot;) ## [1] │ Allô, John-John&lt;?&gt; Ici Joe la frite&lt;.&gt; Surprise&lt;!&gt; Remarquez qu’on ne cherche pas le pattern \"[.?!]\", mais le pattern \"[\\\\.\\\\?\\\\!]\". . (comme nous l’avons vu précédemment), mais aussi ? et ! sont des caractères spéciaux dans le cadre des expressions régulières. Donc, pour dire qu’on parle d’un “vrai” point, point d’interrogation ou point d’exclamation, on utilise l’escape character \\. L’expression régulière est donc [\\.\\?\\!]… Mais on ne s’arrête pas là… En effet, ce n’est pas directement une expression régulière que l’on passe à la fonction, mais plutôt une chaîne de caractères qui est elle-même “transformée” en expression régulière… Il faut donc utiliser l’escape character \\ devant les \\. Et voilà comment on se retrouve à passer le pattern \"[\\\\.\\\\?\\\\!]\". 2.2.3 caractères exclus, gammes de caractères On peut définir une classe de caractères en listant les caractères qu’elle inclut, mais également en listant l’ensemble des caractères exclus en utilisant la notation [^...]: Par exemple, pour trouver tous les caractères qui ne sont ni une voyelle ni un espace: stringr::str_view_all(&quot;turlututu chapeau pointu&quot;, &quot;[^aeiou ]&quot;) ## [1] │ &lt;t&gt;u&lt;r&gt;&lt;l&gt;u&lt;t&gt;u&lt;t&gt;u &lt;c&gt;&lt;h&gt;a&lt;p&gt;eau &lt;p&gt;oi&lt;n&gt;&lt;t&gt;u Enfin, on peut définir des classes de caractères correspondant à des gammes de valeurs en utilisant la notation [...-...] Par exemple, pour trouver tous les chiffres entre 1 et 5: stringr::str_view_all(c(&quot;3 petits cochons&quot;, &quot;101 dalmations&quot;, &quot;7 nains&quot;), &quot;[1-5]&quot;) ## [1] │ &lt;3&gt; petits cochons ## [2] │ &lt;1&gt;0&lt;1&gt; dalmations ## [3] │ 7 nains Pour trouver toutes les lettres entre A et F: stringr::str_view_all(&quot;A132-f445-e34-C308-M2244-Z449-E18&quot;, &quot;[A-F]&quot;) ## [1] │ &lt;A&gt;132-f445-e34-&lt;C&gt;308-M2244-Z449-&lt;E&gt;18 Pour trouver toutes les lettres entre A et F et a et e: stringr::str_view_all(&quot;A132-f445-e34-C308-M2244-Z449-E18&quot;, &quot;[A-Fa-e]&quot;) ## [1] │ &lt;A&gt;132-f445-&lt;e&gt;34-&lt;C&gt;308-M2244-Z449-&lt;E&gt;18 2.2.4 classes prédéfinies Notez qu’il existe des classes de caractères prédéfinies \\w: un caractère alphabétique, ou un chiffre, ou un underscore _ [:alnum:]: un caractère alphanumérique (caractère alphabétique ou chiffre) [:alpha:]: une caractère alphabétique [:lower:]: une caractère alphabétique minuscule [:upper:]: une caractère alphabétique majuscule [:digit:] (qu’on peut aussi écrire \\d): un chiffre [:punct:]: un caractère de ponctuation [:space:]: un espace (espace simple, tabulation, tabulation verticale, nouvelle ligne, etc.) [:blank:]: un “blanc” (espace simple ou tabulation) 2.2.5 quelques exemples pour bien comprendre Une lettre entre A and E, puis un chiffre entre 1 et 6, puis un point, puis “txt”: stringr::str_view_all(c(&quot;A2.txt&quot;,&quot;B5.png&quot;,&quot;C3.txt&quot;,&quot;E6.txt&quot;,&quot;E9.txt&quot;,&quot;F4.txt&quot;), &quot;[A-E][1-6]\\\\.txt&quot;) ## [1] │ &lt;A2.txt&gt; ## [2] │ B5.png ## [3] │ &lt;C3.txt&gt; ## [4] │ &lt;E6.txt&gt; ## [5] │ E9.txt ## [6] │ F4.txt Un chiffre suivi d’un espace: stringr::str_view_all(c(&quot;7 nains&quot;,&quot;3 petits cochons&quot;,&quot;101 dalmatiens&quot;), &quot;[0-9] &quot;) ## [1] │ &lt;7 &gt;nains ## [2] │ &lt;3 &gt;petits cochons ## [3] │ 10&lt;1 &gt;dalmatiens Un caractère suivi d’un chiffre suivi d’un point: stringr::str_view_all(c(&quot;/pouet3.kebop4.kekepwek.kwak&quot;), &quot;.[0-9]\\\\.&quot;) ## [1] │ /poue&lt;t3.&gt;kebo&lt;p4.&gt;kekepwek.kwak Un caractère de ponctuation suivi d’un espace simple et d’une lettre en majuscule: stringr::str_view_all(c(&quot;Allô? c&#39;est John John. Tu as 5 minutes?&quot;), &quot;[:punct:] [:upper:]&quot;) ## [1] │ Allô? c&#39;est John John&lt;. T&gt;u as 5 minutes? 2.2.6 groupes et références arrières Il est possible de créer des groupes au sein des expressions régulières, à l’aide de la notation (...) Par exemple, je peux créer un premier groupe défini par une consonne suivie d’une voyelle à travers l’expression régulière ([^aeiou ][aeiou]), et un deuxième groupe défini de la même manière. Utilisées avec la fonction str_match_all(), l’usage des parenthèses permet d’isoler différentes parties du pattern: stringr::str_match_all(c(&quot;tili tili woup lala tutu pop&quot;), &quot;([^aeiou ][aeiou])([^aeiou ][aeiou])&quot;) ## [[1]] ## [,1] [,2] [,3] ## [1,] &quot;tili&quot; &quot;ti&quot; &quot;li&quot; ## [2,] &quot;tili&quot; &quot;ti&quot; &quot;li&quot; ## [3,] &quot;lala&quot; &quot;la&quot; &quot;la&quot; ## [4,] &quot;tutu&quot; &quot;tu&quot; &quot;tu&quot; L’usage conjoint des groupes et des références arrières permet par ailleurs de rechercher des répétitions de motifs dans les patterns. Ainsi, pour chercher un pattern composé d’une consonne suivi d’une voyelle, répété deux fois, on peut utiliser une référence arrière \\1, \\2, etc. (Comme d’habitude, pour passer l’expression régulière à la fonction on utilise un string, donc on double le \\): stringr::str_view_all(c(&quot;turlututu tralala&quot;), &quot;([^aeiou ][aeiou])\\\\1&quot;) ## [1] │ turlu&lt;tutu&gt; tra&lt;lala&gt; Ici on recherche un motif (il n’y en a qu’un, donc il est numéroté “1”), répété immédiatement après sa première occurrence. 2.2.7 quantificateurs Les quantificateurs permettent de préciser le nombre d’occurrences consécutives d’une classe de caractères ou d’un groupe. zéro ou un: On utilise la notation ? à la suite du caractère ou motif recherché. stringr::str_view_all(c(&quot;file1990-fileB1990-file2005-fileAbis2005-fileA2005&quot;), &quot;file[:alpha:]?\\\\d\\\\d\\\\d\\\\d&quot;) ## [1] │ &lt;file1990&gt;-&lt;fileB1990&gt;-&lt;file2005&gt;-fileAbis2005-&lt;fileA2005&gt; zéro ou plus: On utilise la notation * à la suite du caractère ou motif recherché. stringr::str_view_all(c(&quot;fileA088-fileA-fileB-fileA862&quot;), &quot;fileA\\\\d*&quot;) ## [1] │ &lt;fileA088&gt;-&lt;fileA&gt;-fileB-&lt;fileA862&gt; un ou plus : On utilise la notation + à la suite du caractère ou motif recherché. stringr::str_view_all(c(&quot;fileA0885-fileA-fileB-fileA862&quot;), &quot;fileA\\\\d+&quot;) ## [1] │ &lt;fileA0885&gt;-fileA-fileB-&lt;fileA862&gt; exactement n fois: On utilise la notation {n} à la suite du caractère ou motif recherché. stringr::str_view_all(c(&quot;fileA885.txt-fileA1506.txt-fileA1.txt-fileA862.txt&quot;), &quot;fileA\\\\d{4}\\\\.txt&quot;) ## [1] │ fileA885.txt-&lt;fileA1506.txt&gt;-fileA1.txt-fileA862.txt de n à m fois On utilise la notation {n,m} à la suite du caractère ou motif recherché. stringr::str_view_all(&quot;fileA885.txt-fileA1506.txt-fileA1.txt-fileA862.txt&quot;, &quot;fileA\\\\d{2,4}\\\\.txt&quot;) ## [1] │ &lt;fileA885.txt&gt;-&lt;fileA1506.txt&gt;-fileA1.txt-&lt;fileA862.txt&gt; 2.2.8 ancres et assertions avant-arrière Les ancres permettent de spécifier l’emplacement du motif par rapport à un mot ou à un string. L’ancre ^ fait référence au début d’un string. stringr::str_view_all(c(&quot;Ah! C&#39;est toi John-John?&quot;,&quot;Ben ça alors, Joe la Frite!&quot;), &quot;^[:upper:]&quot;) # on cherche une majuscule en début de string: ## [1] │ &lt;A&gt;h! C&#39;est toi John-John? ## [2] │ &lt;B&gt;en ça alors, Joe la Frite! L’ancre $ fait référence à la fin d’un string. stringr::str_view_all(c(&quot;Allô? John-John?&quot;), &quot;\\\\?$&quot;) ## [1] │ Allô? John-John&lt;?&gt; L’ancre \\\\b fait référence au début ou à la fin d’un mot. # tous les mots se terminant par &quot;a&quot;: stringr::str_view_all(c(&quot;Carla Lea Armelle Marie Lisa Alexia Nina&quot;), &quot;a\\\\b&quot;) ## [1] │ Carl&lt;a&gt; Le&lt;a&gt; Armelle Marie Lis&lt;a&gt; Alexi&lt;a&gt; Nin&lt;a&gt; # tous les mots commençant par une majuscule: stringr::str_view_all(c(&quot;hey Bertrand, aLLeZ vIeNs, il y aura Magda et John-John!&quot;), &quot;\\\\b[:upper:]&quot;) ## [1] │ hey &lt;B&gt;ertrand, aLLeZ vIeNs, il y aura &lt;M&gt;agda et &lt;J&gt;ohn-&lt;J&gt;ohn! 2.2.9 assertions avant-arrière Ces assertions servent à vérifier si un motif existe dans un pattern, sans inclure ce motif dans le résultat. (?=...): Assertion avant (?!...): Assertion avant négative (?&lt;=...): Assertion arrière (?&lt;!...): Assertion arrière négative Exemple d’assertion avant: on cherche les nombres (\\b\\d+\\b) qui sont suivis de ” dalmatiens” stringr::str_view_all(c(&quot;12 labradors, 101 dalmatiens et 4 loulous&quot;), &quot;\\\\b\\\\d+\\\\b(?= dalmatiens)&quot;) ## [1] │ 12 labradors, &lt;101&gt; dalmatiens et 4 loulous Exemple d’assertion avant négative: on cherche les nombres (\\b\\d+\\b) qui ne sont pas suivi de ” dalmatiens” stringr::str_view_all(&quot;12 labradors, 101 dalmatiens et 4 loulous&quot;, &quot;\\\\d+\\\\b(?! dalmatiens)&quot;) ## [1] │ &lt;12&gt; labradors, 101 dalmatiens et &lt;4&gt; loulous Exemple d’assertion arrière: on cherche les mots commençant par une majuscule ([:upper:][:lower:]*) précédés de “Mr”: stringr::str_view_all(&quot;Mr X, Mr Robot, James Bond et Jon Snow&quot;, &quot;(?&lt;=Mr )[:upper:][:lower:]*&quot;) ## [1] │ Mr &lt;X&gt;, Mr &lt;Robot&gt;, James Bond et Jon Snow Exemple d’assertion arrière négative: on cherche tous les mots commençant par une majuscule et finissant les strings ([:upper:][:lower:]*$) précédés par autre chose que “Mr”: stringr::str_view_all(&quot;Mr X, Mr Robot, James Bond et Jon Snow&quot;, &quot;(?&lt;!Mr )[:upper:][:lower:]*$&quot;) ## [1] │ Mr X, Mr Robot, James Bond et Jon &lt;Snow&gt; "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
